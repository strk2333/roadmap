# 算法

## 排序

### 插入排序 （Insertion Sort）

- 概括：插入到合适位置

- 复杂度

  - 时间（一般，最坏，最好）：O( n^2^ ) O( n^2^ ) O(n)
  - 空间：O(1)
  - 稳定

- 步骤

  1. 认为第一个元素是已排序的

  2. 取出下一个元素，在已经排序的元素序列中从后向前扫描，插入元素   -- O( n^2^ ) （一般情况下的时间复杂度）

  3. 重复 2

- 特点

  - \+ 原地 ( in-place ) 算法，空间 O(1)
  - \- 在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间

  ### 

### 选择排序 （Selection Sort）

- 概括：选择未排序部分最值与未排序部分第一个元素交换

- 复杂度

  - 时间：O( n^2^ ) O( n^2^ ) O( n^2^ )
  - 空间：O(1)
  - 不稳定 （相对前后顺序会不同）

- 步骤

  1. 首先在未排序序列中找到最小元素，存放到排序序列的起始位置

  2. 再从剩余未排序元素中继续寻找最小元素，放到已排序序列的末尾.   -- O( n^2^ )

  3. 重复 2

- 特点

  - \+ 简单常用
  - \+ 空间 O(1)
  - \- 任何数据都是 O( n^2^ ), 数据规模越小越好



### 冒泡排序 （Bubble Sort）

- 概括：从起点交换相邻元素位置，将最值冒泡到终点

- 复杂度

  - 时间：O( n^2^ ) O( n^2^ ) O(n)
  - 空间：O(1)
  - 稳定

- 步骤

  1. 比较相邻的元素。如果第一个比第二个大，则交换

  2. 再从剩余未排序元素中继续寻找最小元素，放到已排序序列的末尾    -- O( n^2^ )

  3. 重复 2

- 特点

  - \+ 简单
  - \+ 空间 O(1)



### 希尔排序 （Shell Sort）（extends 插入排序）（缩小增量排序）

- 概括：进行多次间隔递减的分组插入排序

- 复杂度

  - 时间：O( n^1.3^ ) O( n^2^ ) O(n)
  - 空间：O(1)
  - 不稳定

- 步骤

  1. 选择一个增量序列t1，t2，…，tk，其中ti>tj，tk=1

  2. 按增量序列个数k，对序列进行k 趟排序。根据对应的增量ti，将待排序列分割成若干长度为m 的子序列，分别对各子表进行直接插入排序。仅增量因子为1 时，整个序列作为一个表来处理，表长度即为整个序列的长度

  3. 重复 2

- 特点

  - \+ 第一个突破 O(n^2^) 的排序算法



### 归并排序 （Merge Sort）

- 概括：先使每个子序列有序，再将两两有序表合并成一个有序表（2-路归并） 

- 复杂度

  - 时间：O( nlogn ) O( nlogn ) O( nlogn )
  - 空间：O(n)
  - 稳定

- 步骤

  1. 把长度为n的输入序列分成两个长度为n/2的子序列

  2. 对这两个子序列分别采用归并排序

  3. 将两个排序好的子序列合并（比较两个序列的首元素）成一个最终的排序序列 （ 2-路归并 ）

- 特点

  - \+ 性能不受输入数据的影响
  - \+ 表现比选择排序好的多
  - \- 需要额外内存空间



### 快速排序 （Quick Sort）（分治）

- 概括：通过一趟排序将待排记录分隔成独立的两部分（ 从right找小于pivot的值，放在left，从left找大于pivot的值，放在right ），其中一部分记录的关键字均比另一部分的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序。

- 复杂度

  - 时间：O( nlogn ) O( n^2^ ) O(nlogn)
  - 空间：O(nlogn)
  - 不稳定

- 步骤

  1. [基准] 选定基准元素

  2. [分区] 重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（ 相同的数可以到任一边 ）。在这个分区退出之后，该基准就处于数列的中间位置

  3. 重复 2，把小于基准值元素的子数列和大于基准值元素的子数列排序。

- 特点

  - \+ 



### 堆排序 （Heap Sort）

- 概括：堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（ 或者大于 ）它的父节点（ 小顶堆，大顶堆 ）。将待排序序列构造成一个大顶堆，此时，整个序列的最大值就是堆顶的根节点。将其与末尾元素进行交换，此时末尾就为最大值。然后将剩余n-1个元素重新构造成一个堆，这样会得到n个元素的次大值。如此反复执行，便能得到一个有序序列了。

- 复杂度

  - 时间：O( nlogn ) O( nlogn ) O( nlogn )
  - 空间：O(1)
  - 不稳定

- 步骤

  1. 将初始待排序关键字序列(R1,R2….Rn)构建成大顶堆，此堆为初始的无序区

  2. 将堆顶元素R[1]与最后一个元素R[n]交换，此时得到新的无序区( R1, R2, ……Rn-1 )和新的有序区(Rn),且满足R[1,2…n-1]<=R[n]

  3. 由于交换后新的堆顶R[1]可能违反堆的性质，因此需要对当前无序区( R1, R2, ……Rn-1 )调整为新堆，然后再次将R[1]与无序区最后一个元素交换，得到新的无序区( R1, R2, ….Rn-2 )和新的有序区( Rn-1, Rn )。不断重复此过程直到有序区的元素个数为n-1，则整个排序过程完成

- 特点

  - \+ 



### 计数排序 （Counting Sort）

- 概括：将输入的数据值转化为键存储在额外开辟的根据**数据范围**生成的数组空间中，统计出现次数。然后输出结果。

- 复杂度

  - 时间：O( n+k ) O( n+k ) O( n+k )
  - 空间：O(n+k)
  - 稳定

- 步骤

  1. 找出待排序的数组中最大和最小的元素

  2. 统计数组中每个值为 i 的元素出现的次数，存入数组C的第i项

  3. 对所有的计数累加（从C中的第一个元素开始，每一项和前一项相加）
  4. 反向填充目标数组：将每个元素i放在新数组的第 C(i) 项，每放一个元素就将 C(i) 减去1

- 特点

  - \+ 适合范围不大并且集中的数据



### 桶排序 （Bucket Sort）（计数排序的升级版）

- 概括：假设输入数据服从均匀分布，将数据用**映射函数**映射到数量有限的有序的桶里，每个桶再分别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序）

- 复杂度

  - 时间：O( n+k ) O( n^2^ ) O( n )
  - 空间：O(n+k)
  - 稳定

- 步骤

  1. 设置一个定量的数组当作空桶

  2. 遍历输入数据，并且把数据一个一个放到对应的桶里去

  3. 对每个不是空的桶进行排序
  4. 从不是空的桶里把排好序的数据拼接起来

- 特点

  - \+ 桶划分的越小，各个桶之间的数据越少，排序所用的时间也会越少。但相应的空间消耗就会增大



### 基数排序 （Radix Sort）

- 概括：基数排序是按照低位先排序，然后收集；再按照高位排序，然后再收集；依次类推，直到最高位。有时候有些属性是有优先级顺序的，先按低优先级排序，再按高优先级排序。最后的次序就是高优先级高的在前，高优先级相同的低优先级高的在前。

- 复杂度

  - 时间：O( n\*k ) O( n\*k ) O( n\*k )
  - 空间：O(n+k)
  - 稳定

- 步骤

  1. 取得数组中的最大数，并取得位数

  2. arr为原始数组，从最低位开始取每个位组成radix数组

  3. 对radix进行计数排序（利用计数排序适用于小范围数的特点）

- 特点

  - \+ 



> [Ref]: https://www.cnblogs.com/onepixel/articles/7674659.html	"十大经典排序算法（动图演示）"

<!--注：有很多办法可以将任意排序算法变成稳定的，但是，往往需要额外的时间或者空间。-->



## 树

### 二叉树

二叉搜索树上所花费的时间与这棵树的高度成正比

区分树的高度和深度

二叉搜索树：
 左子树中的关键字的值小于根节点中关键字的值，右子树中关键字的值大于根节点中关键字的值

二叉搜索树的遍历：
 先序遍历
 中序遍历
 后序遍历
 其中序是指根节点的位置

二叉搜索树的查找
 迭代比递归更加高效
 比较关键字的值，大于向右，小于向左

插入和删除：
 插入类似于查找，即查找到一个空的合适的位置，将该节点插入

删除则分为三种情况
 将删除的节点没有孩子节点，直接删除
 将删除的节点只有一个孩子节点，将这个孩子提升到将删除节点的位置，并修改将删除节点的父节点，
 将删除的节点有两个孩子节点，查找将要删除节点的后继，并让该后继占据将要删除的节点的位置，让将删除节点的右子树部分成为那个后继的新的右子树，并且将删除节点的左子树成为那个后继的新的左子树

红黑树：

红黑树保证没有一条路径会比其它路径长出两倍，是近似平衡的，平衡二叉树是绝对平衡的

红黑树性质：

- 每个节点是红色的或者是黑色的
- 根节点是黑色的
- 每个叶节点是黑色的
- 如果一个节点是红色的，那么它的两个子节点是黑色的
- 对于每个节点，从该节点到其所有后代叶节点的简单路径上，均包含数目相同的黑色节点数，成为黑高

红黑树的旋转：
 左旋和右旋
 左旋是靠左边的节点下滑，夺取右子树的左子树作为自己的右子树，同时自己重新成为右子树的左子树
 右旋是靠右边的节点下滑，夺取左子树的右子树作为自己的左子树，同时自己重新成为左子树的右子树

红黑树的插入：
 红黑树的性质2或者4被破坏
 插入的节点首先着色为红色
 为保持红黑树的性质，调用辅助程序对红黑树的节点重新着色并进行旋转

红黑树的删除：
 删除节点之后，调用辅助程序通过改变颜色和执行旋转来恢复红黑树性质
 如果删除的节点是红色，则不需要对树进行恢复



1. 当出现新的节点时默认为红色插入，如果其父节点为红色，则对其递归向上换色，如果根节点由此变为红色，则对根节点进行左旋（右侧过深）或右旋（左侧过深），之后从根节点向下修改颜色 
2. 从根节点检查红色节点是否符合路径上的黑色节点数量一致，如果不一致，对该节点进行左旋（右侧黑色节点数量更多）或右旋（左侧黑色节点数量更多），并变换颜色，重复2操作直到符合红黑树规则。





## BFS ( Breadth First Search ) & DFS ( Depth First Search )

https://www.cnblogs.com/wzl19981116/p/9397203.html



### BFS

- ​	模板

  ```
  // 模板1 放入头节点
  while queue 不空:
      cur = queue.pop()
      for 节点 in cur的所有相邻节点:
          if 该节点有效且未访问过:
              queue.push(该节点)
  
  // 模板2
  level = 0
  while queue 不空:
      size = queue.size()
      while (size --) {
          cur = queue.pop()
          for 节点 in cur的所有相邻节点:
              if 该节点有效且未被访问过:
                  queue.push(该节点)
      }
      level ++;
  
  ```

- 





## 动态规划
### 组成
1. 确定状态  

   - 两个意识 (去掉 a<sub>k</sub>后, n-a<sub>k</sub>也是最优解)
     - 最后一步 a~k~

     - 子问题 求n-a<sub>k</sub>的最优解

   - 设置状态 f(x)=x

     - x=n
     - x=n-a<sub>k</sub>
     - f(n)=f(n-a<sub>k</sub>) + 1

   -  a<sub>k</sub>的值

     - min{f(n-a<sub>k</sub>) + 1}    a<sub>k</sub>取所有可能值

   -  重复计算

     - 保存计算结果, 改变计算顺序

   

3. 转移方程

4. 初始条件和边界情况

5. 计算顺序



### 递推







## Exp.

### Delete node in node list

```c++
void deleteNode(ListNode* node) {
	node->val = node->next->val;
	node->next = node->next->next;
}
```

  






### 递归





### Method

- 双指针







### Tips

- 二分法技巧
  - https://blog.csdn.net/CCSGTC/article/details/80586181