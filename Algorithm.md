## Algorithm

### 排序









### 树

#### 二叉树

二叉搜索树上所花费的时间与这棵树的高度成正比

区分树的高度和深度

二叉搜索树：
 左子树中的关键字的值小于根节点中关键字的值，右子树中关键字的值大于根节点中关键字的值

二叉搜索树的遍历：
 先序遍历
 中序遍历
 后序遍历
 其中序是指根节点的位置

二叉搜索树的查找
 迭代比递归更加高效
 比较关键字的值，大于向右，小于向左

插入和删除：
 插入类似于查找，即查找到一个空的合适的位置，将该节点插入

删除则分为三种情况
 将删除的节点没有孩子节点，直接删除
 将删除的节点只有一个孩子节点，将这个孩子提升到将删除节点的位置，并修改将删除节点的父节点，
 将删除的节点有两个孩子节点，查找将要删除节点的后继，并让该后继占据将要删除的节点的位置，让将删除节点的右子树部分成为那个后继的新的右子树，并且将删除节点的左子树成为那个后继的新的左子树

红黑树：

红黑树保证没有一条路径会比其它路径长出两倍，是近似平衡的，平衡二叉树是绝对平衡的

红黑树性质：
 每个节点是红色的或者是黑色的
 根节点是黑色的
 每个叶节点是黑色的
 如果一个节点是红色的，那么它的两个子节点是黑色的
 对于每个节点，从该节点到其所有后代叶节点的简单路径上，均包含数目相同的黑色节点数，成为黑高

红黑树的旋转：
 左旋和右旋
 左旋是靠左边的节点下滑，夺取右子树的左子树作为自己的右子树，同时自己从新成为右子树的左子树
 右旋是靠右边的节点下滑，夺取左子树的右子树作为自己的左子树，同事自己从新成为左子树的右子树

红黑树的插入：
 红黑树的性质2或者4被破坏
 插入的节点首先着色为红色
 为保持红黑树的性质，调用辅助程序对红黑树的节点重新着色并进行旋转

红黑树的删除：
 删除节点之后，调用辅助程序通过改变颜色和执行旋转来恢复红黑树性质
 如果删除的节点是红色，则不需要对树进行恢复







### 动态规划
#### 组成
1. 确定状态  

   - 两个意识 (去掉 a<sub>k</sub>后, n-a<sub>k</sub>也是最优解)
     - 最后一步 a~k~

     - 子问题 求n-a<sub>k</sub>的最优解

   - 设置状态 f(x)=x

     - x=n
     - x=n-a<sub>k</sub>    
     - f(n)=f(n-a<sub>k</sub>) + 1

   -  a<sub>k</sub>的值

     - min{f(n-a<sub>k</sub>) + 1}    a<sub>k</sub>取所有可能值

   -  重复计算

     - 保存计算结果, 改变计算顺序

   

3. 转移方程

4. 初始条件和边界情况

5. 计算顺序



#### 递推







## Exp.

- Delete node in node list

- ```c++
      void deleteNode(ListNode* node) {
          node->val = node->next->val;
          node->next = node->next->next;
      }
  ```

- 